/**
 * Gate API v4
 * APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user\'s behalf.
 *
 * Contact: support@mail.gate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { DepositAddress } from '../model/depositAddress';
import { LedgerRecord } from '../model/ledgerRecord';
import { SubAccountTransfer } from '../model/subAccountTransfer';
import { Transfer } from '../model/transfer';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class WalletApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     *
     * @summary Generate currency deposit address
     * @param currency Currency name
     */
    public async getDepositAddress(
        currency: string,
    ): Promise<{ response: http.IncomingMessage; body: DepositAddress }> {
        const localVarPath = this.client.basePath + '/wallet/deposit_address';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        const localVarFormParams: any = {};

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling getDepositAddress.');
        }

        localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, 'string');

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: true,
            json: true,
        };
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        const authSettings = ['apiv4'];
        return this.client.request<DepositAddress>(localVarRequestOptions, 'DepositAddress', authSettings);
    }

    /**
     * Record time range cannot exceed 30 days
     * @summary Retrieve deposit records
     * @param opts Optional parameters
     * @param opts.currency Filter by currency. Return all currency records if not specified
     * @param opts.from Time range beginning, default to 7 days before current time
     * @param opts.to Time range ending, default to current time
     * @param opts.limit Maximum number of records returned in one list
     * @param opts.offset List offset, starting from 0
     */
    public async listDeposits(opts: {
        currency?: string;
        from?: number;
        to?: number;
        limit?: number;
        offset?: number;
    }): Promise<{ response: http.IncomingMessage; body: Array<LedgerRecord> }> {
        const localVarPath = this.client.basePath + '/wallet/deposits';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        const localVarFormParams: any = {};

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: true,
            json: true,
        };
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        const authSettings = ['apiv4'];
        return this.client.request<Array<LedgerRecord>>(localVarRequestOptions, 'Array<LedgerRecord>', authSettings);
    }

    /**
     * Record time range cannot exceed 30 days  > Note: only records after 2020-04-10 can be retrieved
     * @summary Transfer records between main and sub accounts
     * @param opts Optional parameters
     * @param opts.subUid Sub account user ID. Return records related to all sub accounts if not specified
     * @param opts.from Time range beginning, default to 7 days before current time
     * @param opts.to Time range ending, default to current time
     * @param opts.limit Maximum number of records returned in one list
     * @param opts.offset List offset, starting from 0
     */
    public async listSubAccountTransfers(opts: {
        subUid?: string;
        from?: number;
        to?: number;
        limit?: number;
        offset?: number;
    }): Promise<{ response: http.IncomingMessage; body: Array<SubAccountTransfer> }> {
        const localVarPath = this.client.basePath + '/wallet/sub_account_transfers';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        const localVarFormParams: any = {};

        opts = opts || {};
        if (opts.subUid !== undefined) {
            localVarQueryParameters['sub_uid'] = ObjectSerializer.serialize(opts.subUid, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: true,
            json: true,
        };
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        const authSettings = ['apiv4'];
        return this.client.request<Array<SubAccountTransfer>>(
            localVarRequestOptions,
            'Array<SubAccountTransfer>',
            authSettings,
        );
    }

    /**
     * Record time range cannot exceed 30 days
     * @summary Retrieve withdrawal records
     * @param opts Optional parameters
     * @param opts.currency Filter by currency. Return all currency records if not specified
     * @param opts.from Time range beginning, default to 7 days before current time
     * @param opts.to Time range ending, default to current time
     * @param opts.limit Maximum number of records returned in one list
     * @param opts.offset List offset, starting from 0
     */
    public async listWithdrawals(opts: {
        currency?: string;
        from?: number;
        to?: number;
        limit?: number;
        offset?: number;
    }): Promise<{ response: http.IncomingMessage; body: Array<LedgerRecord> }> {
        const localVarPath = this.client.basePath + '/wallet/withdrawals';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        const localVarFormParams: any = {};

        opts = opts || {};
        if (opts.currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(opts.currency, 'string');
        }

        if (opts.from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(opts.from, 'number');
        }

        if (opts.to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(opts.to, 'number');
        }

        if (opts.limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(opts.limit, 'number');
        }

        if (opts.offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(opts.offset, 'number');
        }

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: true,
            json: true,
        };
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        const authSettings = ['apiv4'];
        return this.client.request<Array<LedgerRecord>>(localVarRequestOptions, 'Array<LedgerRecord>', authSettings);
    }

    /**
     * Transfer between different accounts. Currently support transfers between the following:  1. spot - margin 2. spot - futures(perpetual) 2. spot - delivery
     * @summary Transfer between accounts
     * @param transfer
     */
    public async transfer(transfer: Transfer): Promise<{ response: http.IncomingMessage; body?: any }> {
        const localVarPath = this.client.basePath + '/wallet/transfers';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'transfer' is not null or undefined
        if (transfer === null || transfer === undefined) {
            throw new Error('Required parameter transfer was null or undefined when calling transfer.');
        }

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: true,
            json: true,
            body: ObjectSerializer.serialize(transfer, 'Transfer'),
        };
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        const authSettings = ['apiv4'];
        return this.client.request<any>(localVarRequestOptions, '', authSettings);
    }

    /**
     *
     * @summary Transfer between main and sub accounts
     * @param subAccountTransfer
     */
    public async transferWithSubAccount(
        subAccountTransfer: SubAccountTransfer,
    ): Promise<{ response: http.IncomingMessage; body?: any }> {
        const localVarPath = this.client.basePath + '/wallet/sub_account_transfers';
        const localVarQueryParameters: any = {};
        const localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const localVarFormParams: any = {};

        // verify required parameter 'subAccountTransfer' is not null or undefined
        if (subAccountTransfer === null || subAccountTransfer === undefined) {
            throw new Error(
                'Required parameter subAccountTransfer was null or undefined when calling transferWithSubAccount.',
            );
        }

        const localVarUseFormData = false;

        const localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: true,
            json: true,
            body: ObjectSerializer.serialize(subAccountTransfer, 'SubAccountTransfer'),
        };
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        const authSettings = ['apiv4'];
        return this.client.request<any>(localVarRequestOptions, '', authSettings);
    }
}
